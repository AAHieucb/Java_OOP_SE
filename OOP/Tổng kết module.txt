# Structured programming 
Bao gồm việc chia nhỏ vấn đề, tách thành từng module độc lập nhau, organized code, dùng ifelse thay cho goto.
1 concern là 1 phần xử lý của 1 object khác nhau. VD ta viết 1 hàm cực kỳ dài, trong đó có logging, authentication, access database, tạo transaction db mới, xử lý chuyển tiền, rollback or commit. Mỗi cái này là 1 concern và tách hàm riêng.
Chia nhỏ có mục đích là tái sử dụng, dễ kiểm thử, cô lập code.

-> Pb:
Validation: Do the right thing. VD: nhập input phải đúng format
Verification: Do the thing right. VD: nhập input đúng rồi nhưng phải đúng tk mk trên database



# Clean code
Code tách ra or viết trước vì đoán sẽ đổi trong tương lai or tái sử dụng => k nên làm v trừ khi chắc chắn 100% vì sẽ làm code base rối lên
Luôn đổi hằng số config thành 1 cuc để ở file config riêng
Nên dùng scope biến và access modifier của class sát nhất với TH dùng nó, k khai báo thừa
Khi nào dùng recursion, thực tế performance của iterative tốt hơn recursion. Đôi khi dùng nó nếu muốn code dễ hiểu hơn với các phần implement phức tạp thôi.



//!!!!!!!
# Encapsulation:
Đóng gói methods và attributes(thành private) vào class đã là tính đóng gói r. 
Tính đóng gói quan trọng kp vì nó ép ta gói vào class mà vai trò của nó là ngăn cản unwanted directly access bởi other object
Gói các biến và hàm private, protected -> tránh các class bên ngoài truy cập vào thuộc tính đối tượng tùy tiên, cung API truy cập bởi các module khác thấy các type và method getter, setter.



#***Tính trừu tượng trong OOP
Dùng setter getter cho attribute đặt private để chỉ thay đổi theo 1 hướng chuẩn định sẵn. Ẩn đi sự phức tạp chỉ cần cung ra API để sử dụng. Người ta k cần biết bên trong nó cụ thể là gì nhưng vẫn dùng được nó. 
Ta kbh truy cập vào thuộc tính của 1 lớp bằng cách gọi trực tiếp mà luôn làm điều đó qua 1 phương thức của lớp, vì 1 thuộc tính đổi phải bắt nguồn từ 1 hành động nào đó. VD gọi hàm ăn cơm thì đổi field bụng no, ta k được để ngừoi khác gán bụng no mà k gọi hàm ăn cơm được

Getter, setter sửa theo ý của ta trong TH cần thiết chứ nếu ta để get set tùy ý thà để public còn hơn.
VD: ta chỉ va_zin cho máy tính khi chưa dùng được nó quá 5 năm. Nếu ta để con_zin là biến public thì ai cũng tác động vào nó được và điều này k tốt. Khi đó ta phải để private còn public ta viết hàm va_zin cho nó check nếu chưa dùng được 5 năm thì mới thực hiện va_zin.
Tại sao gọi là tính trừu tượng. Vì ta định nghĩa con_zin là private xong viết phương thức va_zin cho nó. Các coder khác nhìn vào chỉ cần biết là có thuộc tính va_zin và gọi nó chứ cũng mơ hồ kb bên trong xử lý như nào nên mới gọi nó là tính trừu tượng. Vì bản thân ta đã xử lý logic bên trong chuẩn hết r và những người khác chỉ cần gọi chứ k quan tâm bên trong có gì. Đó là bản chất mà nếu dùng public sẽ k thể xử lý được vì khi đó ai cũng va_zin bất cứ lúc nào, k còn tính chất ta mong muốn nx. Nó ẩn đi sự phức tạp cho người khác khi dùng thứ đang code vì họ k cần bt bên trong có gì, tập trung vào cốt lõi cần thiết



# Tính kế thừa: 
Nói về các mức độ của biến trong class và các cấp độ kế thừa

-> Access modifier: public truy cập mọi nơi trong project, protected truy cập được từ trong lớp và các con và instance của nó trong các lớp cùng gói, none hay default chỉ truy cập từ lớp khai báo và các lớp cùng gói với lớp khai báo, private chỉ truy cập từ trong chính lớp gốc.
Vd: A và B same package và A có 1 instance của B thì biến private của B chỉ dùng ở B, biến protected, none, public của B dùng được ở A.
Vd: A và B khác package và A có 1 instance của B thì chỉ truy cập được public, 3 type còn lại thì k.
Vd: A và B khác package và A kế thừa B thì A dùng được public, protected, k dùng được none và private => key
Nếu 2 class thuộc 2 package khác nhau thì phải import package vào.
Quan hệ tương tự với biến static nhưng static k cần 1 instance. 

-> visibility của class chỉ là public, abstract, final, private, static: public là mặc định, final là class k thể bị kế thừa và mọi phương thức hay hàm đều là private or final. Private class k thể khởi tạo instance ở class khác, nếu private class được định nghĩa trong 1 class khác thì chỉ có thể dùng được bth trong class đó. static class dùng cho nested class cũng chỉ dùng trong phạm vi class parent.
Các hàm k thể kế thừa là constructor và operator =(perform cùng task với constructor)

-> Constructor của cha luôn được gọi trước con và luôn được gọi khi khai báo instance của con, kể cả con k có super vẫn gọi vào default constructor của cha. Nhưng nếu muốn gọi vào constructor có tham số khác của cha thì phải có super(list params). Constructor cha thực hiện sau nhưng lại thực hiện xong trước constructor của con.

-> Generalization và Specialization trong hướng đối tượng:
Generalization là tổng quát hóa. Trong cây kế thừa thì các class càng gần root thì mức độ tổng quát hóa càng cao. Nó ám chỉ vc convert hay upcast 1 subclass sang superclass, khiến cho subclass càng general hơn. Vì các class tầng cao thường cung API tổng quát hơn các class tầng thấp
Specialization là quá trình ngược lại

Hình vuông là đặc biệt hóa của hcn và hcn là tổng quát hóa của hv => lớp cơ sở, lớp kế thừa
Có 3 dạng kế thừa: kế thừa class, kế thừa abstract class, kế thừa interface
Child class có thể tái sử dụng code của cha và mở rộng theo 2 cách: override method, thêm method và atts mới. 



#***Tính đa hình
Là vc trình biên dịch tìm thực hiện hàm ở lớp con ưu tiên hơn lớp cha.

-> Đa hình thời gian chạy(override), đa hình thời gian biên dịch(overloading)
override là 2 class cùng phương thức or biến thì con đè cha, k được với static và final. Điều kiện là con phải có visibility mở rộng hơn or bằng cha: public > protected > none > private
overload là 2 class cùng hàm và khác tham số thì 1 tên hàm làm nhiều vai trò được.
Override là cùng params và tên để ghi đè. Parent có overriden method, child có overriding method. Là 1 kiểu redefinition phân biệt với overload. K thể override constant, static, private method of class cha => signature = name(params)
Overload signature của function thì tên, type trả về và visibility phải giống nhau, chỉ có params là khác nhau vì nó là điều kiện để xác định các function khi gọi.

-> Đa hình tĩnh dùng để chỉ các tính năng đa hình dùng bị sai k tối ưu.
VD mỗi class A1, A2, A3 kế thừa abstract class B thì phải implement độc lập đa hình từng hàm x() trong B với các tham số khác nhau, tức là trong B có nhiều hàm x() rỗng để trong từng class A ta implement lại hàm mà nó cần. Điều này là không tốt vì giả sử ta cần thêm 1 class A4 mới toanh thì về lý thuyết ta chỉ cần thêm vào A4 là xong nhưng thực tế lại phải thêm 1 hàm x() với tham số mới nx vào class B và cứ thế nó phình to class B ra. Vc overload như v cũng là đa hình(tĩnh) nhưng chẳng để làm gì. Thậm chí vc kế thừa abstract class mà như v thì cx coi như vô dụng. Thông thường overload kiểu này nó k là abtract class mà tạo instance của class B bình thường luôn và A1, A2, A3 chỉ là case nhỏ của B sử dụng trong vài TH lẻ loi thôi còn instance của B vẫn là chính. Ở đây nếu B là abstract thì ta phải đinh ninh rằng k tạo instance cho B mà B chỉ định nghĩa các thuộc tính và method chung nhất, k cụ thể. 
Nếu các class A1, A2 có các hàm như nhau mà cần tham số khác nhau thì ta có thể biến các tham số đó thành aggregation lúc khởi tạo or thông qua setter thì các hàm đa hình tĩnh có thể chuyển thành đa hình động

Nguyên tắc OCP trong SOLID: open for extension, close for modification => ưu tiên vc mở rộng và k ưu tiên vc thay đổi code. Tức là như VD ở bên trên, ta muốn mở rộng dự án, thêm các tính năng thì ta thêm class A4 và kế thừa từ B xong cứ code như bth là open for extension, còn các class khác dù có quan hệ với A4 nhưng lại k thay đổi code vì nó close for modification. Nhờ v, tính chặt chẽ, nhất quán được đảm bảo.

-> Một cách hay khác để tạo 1 function - 1 responsibility: 2 bước
B1 là kế thừa: A1, A2 kế thừa abstract B, B định nghĩa các abstract function của các A và A implement nó
B2 là delegation: C là class có instance của B lấy từ new A1, new A2 nhưng C k gọi hàm trực tiếp của B để chạy mà C chạy thông qua 1 class D(context). C có 1 biến global D và các biến temporary tạo trong từng hàm là B. class D chứa B là 1 aggregation và ta gán temporary B cho D r gọi hàm của B thông qua hàm của D => delegation là vc ta k gọi hàm trực tiếp để thực hiện chức năng mà gọi thông qua 1 class khác. 
=> Cái delegation nhiều TH nó k đem lại ích lợi gì

Vd dùng delegation có lợi: class A có hàm caculate và gọi nó trong main của A. Dùng delegation sẽ giúp bao đóng nó trong 1 class bằng cách nhét hàm calculate vào 1 class mới là Calculator và cho Calculator implements interface ICalculator có hàm calculate. Thứ nhất, mỗi khi tính toán ta nhìn vào ICalculator sẽ biết có thể dùng những hàm gì để tính toán mà k cần biết bên trong nó thực hiện cái gì, tận dụng được vai trò của interface. Thứ hai, bao đóng nó trong class có tác dụng phân chia nhiệm vụ cho từng class rằng mỗi class thực hiện 1 chức năng. Chẳng hạn về sau có hàm run, convert hay các utilities gì khác cũng có thể tạo ra từng class riêng, mà khi tạo class riêng thì có thể tận dụng nhiều tính kế thừa hay các thứ để tận dụng tối đa vc tái sử dụng của OOP. 

Vai trò thực sự của interface: Để khắc phục lỗi của tính kế thừa(mà nó được khắc phục sẵn trong aggregation nhưng aggregation k tốt bằng inheritance về cấu trúc). Vấn đề kim cương gặp trong tính kế thừa được khắc phục thông qua interface. VD: Chim và chó đều kế thừa từ Animal, nhưng 1 con có thể bay, 1 con có thể chạy. Ta định nghĩa 2 interface bay và chạy để 2 class implements riêng chứ extends cái Animal k thể hiện được điều đó => VD DFS và Cutvertex đều kế thừa từ Algorithm nhưng 1 thuật toán có thể có thêm chức năng này mà thuật toán khác k có, ta có thể cho nó implements 2 interface khác nhau để giải quyết điều này. Khi gọi thì dùng instance type là interface đó để gọi.

Quay lại vấn đề ban đầu: delegation có lợi gì ở đây k?
Class Context bao gói các hàm liên quan của class Algorithm(thực chất có mỗi buildStep và play) cũng như vc tạo 1 class thực hiện hàm calculate ở bên trên là để 1 class thực hiện 1 chức năng. Đúng hơn class Context nên để tên là 1 class có chức năng RunAlg trong dự án. Class Context có thể kế thừa or aggregation Algorithm tùy lợi ích muốn sử dụng nhưng khi đã dùng như này thì để aggregation sẽ ok hơn vì nó chỉ thực hiện 1 chức năng chứ k thực sự có vai trò kế thừa. Nhưng ở đây hầu như k có lợi ích gì vì chỉ có duy nhất 1 chức năng buildStep đó mà dự án lại nhỏ k tái sử dụng gì được nx. Ở đây nó y hệt như vc gọi hàm trực tiếp của class Alg v. Nó đôi khi cũng có lợi nếu như cần tiền xử lý or hậu xử lý chung cái gì đó trong Context trước khi gọi hàm của Alg. 
=> Nếu muốn cái này có ích thì class Algorithm phải có nhiều chức năng hơn, VD 4 chức năng đi và class Context chỉ gọi runAlgorithm là 1 chức năng trong 4 chức năng đó mà thôi thì class này có vai trò kiểu tách chức năng ấy, 1 class - 1 chức năng tách ra thì ok. Nhờ đó từng Algorithm đều có chung chức năng này thì class này có ý nghĩa. Chứ nếu class Algorithm chỉ có duy nhất 1 chức năng là chạy thuật toán, xong tạo Context biểu diễn đúng mỗi chức năng đó thôi thì nó gọi mẹ trực tiếp cho rồi. Cái này giống như Dog, Cat, Tiger cùng kế thừa abstract Animal nhưng trong class Animal cũng như 3 class con chỉ có đúng tính năng run() là cho con vật chạy thôi thì cần méo gì phải tạo interface AnimalRun có mỗi hàm run đúng k, gọi mẹ biến Animal a.run() luôn cho nhanh. Trừ khi Animal có nhiều hành động khác ngoài run

-> Tính đa hình bình thường đó là method polymorphism. Còn Object polymorphism là thể loại 1 object thể hiện nhiều type khác nhau(bằng vc upcast và downcast), 1 interface được nhiều object có type khác nhau implements.
Đa hình trong thực tế thể hiện VD 1 cái remote control có thể điều khiển được nhiều thiết bị điện tử, Vd các thiết bị điện tử đó cùng implements 1 interface.



#***Convert condition thành polymorphism
Customer customer = findCustomer(...); 
... 
   if (customer == null) { 
	name = “occupant”  
   } else { 
	name = customer.getName()
   }  
if (customer == null) { 
...
=> Thực tế nên dùng:
public class NullCustomer extends Customer {

   public String getName() {
	return “occupant”
}
------------------------------------------------------------
Customer c = findCustomer()
name = c.getName()

=> Nhưng thực ra là như nhau vì hàm findCustomer sẽ phải check nếu null thì return ra NullCustomer. Điểm lợi hơn chắc là hàm findCustomer nó bị ẩn đi thì dùng if else tốt hơn. Như v sẽ dùng được cho nhiều trường khác cũng gán khi null chứ k chỉ name
=> PP này gọi là thay đổi condition bằng polymorphism => 1 kỹ thuật trong OOP, thực tế số lượng if else vẫn v nhưng nó ẩn các cái đó vào trong class or chia vào các hàm. Mục đích của nó là làm code dễ hiểu hơn và dễ thay đổi trong tương lai. VD 1 behavior mới xuất hiện hay 1 thuộc tính mới thì sửa dễ hơn. Thông qua việc đóng gói điều kiện vào trong các class, logic đổi sẽ chỉ đổi trong các class đó mà k ảnh hưởng tới các class k làm tính năng đó.

VD khác: 
if (itemType == "book") {
    if (onSale) {
        price = bookPrice * 0.8;
    } else {
        price = bookPrice;
    }
} else if (itemType == "DVD") {
    if (onSale) {
        price = dvdPrice * 0.7;
    } else {
        price = dvdPrice;
    }
} else if (itemType == "software") {
    if (onSale) {
        price = softwarePrice * 0.9;
    } else {
        price = softwarePrice;
    }
}
=> Giả sử thêm điều kiện khác ngoài onSale thì lại viết tiếp if else vào còn gì

Fix:
public interface PriceCalculator {
    double calculatePrice(double basePrice, boolean onSale);
}
public class BookPriceCalculator implements PriceCalculator {
    public double calculatePrice(double basePrice, boolean onSale) {
        if (onSale) {
            return basePrice * 0.8;
        } else {
            return basePrice;
        }
    }
}
public class DVDPriceCalculator implements PriceCalculator {
    public double calculatePrice(double basePrice, boolean onSale) {
        if (onSale) {
            return basePrice * 0.7;
        } else {
            return basePrice;
        }
    }
}
public class SoftwarePriceCalculator implements PriceCalculator {
    public double calculatePrice(double basePrice, boolean onSale) {
        if (onSale) {
            return basePrice * 0.9;
        } else {
            return basePrice;
        }
    }
}

Sử dụng:
PriceCalculator calculator;
if (itemType == "book") {
    calculator = new BookPriceCalculator();
} else if (itemType == "DVD") {
    calculator = new DVDPriceCalculator();
} else if (itemType == "software") {
    calculator = new SoftwarePriceCalculator();
}
price = calculator.calculatePrice(basePrice, onSale);
=> Code dễ hiêu hơn



#***Interface và abstract class
Có thể đa kế thừa. Ngôn ngữ hiện đại như Java, C# cho phép function interface có default implementation.

-> TH buộc cần đa hình với abstract class. 
VD: học sinh, giáo viên, phụ huynh đều kế thừa từ lớp con người. Ta muốn trong 1 class có 1 list 3 loại này thì ta phải tạo 3 list nhưng nếu nhờ kế thừa đa hình nên Person có thể là 1 trong 3 người này đều được nên ta có thể tạo 1 List<Person> ok.

-> Khi một nhóm đối tượng cùng bản chất kế thừa cùng một class thì nên sử dụng abstract class. Còn khi một nhóm đối tượng không có cùng bản chất nhưng chúng có hành động giống nhau thì sử dụng interface. VD Car Person Dog cùng implement Move interface. 

Cái này cũng có ích lợi như hàm println + toString đó. Nó chỉ cần tạo 1 interface Move cho các class cần dùng thì implements. Xong tạo 1 class có thể làm gì đó với các class có khả năng move(implements interface Move) chứ k cần làm riêng Car, Person, Dog mà dùng class Move chung cũng như println dùng với các class implements mà có tính năng toString



#***Bản chất dùng Static
Khi nào dùng static? static dùng khi ta cần dùng 1 biến or 1 hàm global của 1 class gì đó mà k cần instance.
VD: ta có 1 class Student chứa thông tin của từng học sinh nhưng trong class lại có 1 biến numberOfStudent lưu số lượng học sinh là static sẽ được cộng lên mỗi khi 1 hs mới được sinh ra. Thực tế biến numberOfStudent và hàm increaseNumberOfStudent là static và k dùng được các biến non-static nhưng các hàm non-static lại gọi được hàm static bên trong nên ta có thẻ tạo 1 class riêng global lưu biến static numberOfStudent và hàm static increaseNumberOfStudent thoải mái và dùng độc lập với class Student được. Ta có thể để nó trong class Student cũng được, cần chú ý OOP vì numberOfStudent k phải là 1 thuộc tính của 1 học sinh. Nó nên nằm trong 1 class mới là School.
VD ta cần tạo ra 10 graph mặc định, ta có thể dùng 10 static instance của class Graph dùng global

-> Khi nào dùng composition và aggregation? Với 1 kiểu biến của class, nếu biến đó chỉ dùng 1 lần xuyên suốt class thì ta ưu tiên dùng composition luôn, còn biến đó được tạo đi tạo lại nhiều lần thì dùng aggregation, để ý vòng đời biến nx.



# Copy constructor:
Trong java k có default copy constructor mà ta phải tự tạo. Ta có thể tạo thủ công bằng cách gán từng trường vào, đó gọi là shallow copy.

Khi có mutable field:
Mutable field là các biến class như Date, String,... thì vc gán bằng là ta gán địa chỉ nên k đúng. Khi đó ta phải dùng deep copy VD: this.startDate = new Date(variable.startDate.getTime()); để có vùng nhớ mới cùng giá trị.



## SOLID:
OOP chỉ là các tính chất của lập trình hướng đối tượng. SOLID mới là các code để tạo ra design OOP chuẩn, khi code xong cũng phải thỏa mãn tính chất của OOP.

VD state pattern đổi state của 1 đơn hàng. Class Order chứa biến private state. Class abstract State được kế thừa bởi nhiều class PreparingState, PackagingState, ShippingState,... và có hàm execute để làm gì đó. Có thể gọi order.changeState(new PackegingState()); để truyền vào đổi biến private state của Order



#***Single responsibility principle(SRP):
Nếu 1 class chỉ lo 1 chức năng sẽ giúp duy trì tính chất high cohesion vì mỗi thành phần trong module đều functionally related, lý do duy nhất class đó thay đổi là chính chức năng đó thay đổi, bất cứ 1 cái gì ở function khác đều k ảnh hưởng và k có tác động.
Bản chất ta tạo ra 1 hàm cho class là vì đối tượng đó có hành vi đó chứ kp ta thêm vào vì ta cần dùng.
VD: class ADSLModem và DialUpModem cùng implement 1 interface Modem lo 2 nhiệm vụ connect và transfer(có 2 hàm này). Client nhận 1 interface cho 2 hàm làm 2 việc khác nhau => họ khuyên nên tách ra 2 class ADSLConnection và ADSLTransfer, tương tự với DialUpModem. Nếu dùng interface có thể tách thành ModemConnection và ModemTransfer cho từng class implements cái tương ứng. Trong client gọi connect và transfer truyền vào truyền vào đúng loại interface mới được

Cái bên trên ta dùng interface là vì có 2 class có hàm chung và client muốn gọi hàm từ cả 2 class đó nên dùng chung biến interface chứ tính chất SRP chỉ là vc tách class gốc thành các class con lo từng chức năng riêng mà thôi. VD: class ADSL rất lớn có rất nhiều thuộc tính và và tính năng, trong đó có connect và transfer thì tách thành ADSLConnection và ADSLTransfer, tách thành 2 class riêng và implements 2 hàm đó, sau đó cho nó thành 2 biến connection và trasfer trong class gốc ADSL(khi nó đúng là thuộc tính). Tức nó biến 2 hàm thành 2 biến trong class đó để giảm chức năng nhưng tăng thuộc tính. Khi client cần connect thì dùng thuộc tính connection ok 
Thực ra class Connection và Transfer tính năng phải đủ lớn mới tách ra như v.
=> Góc nhìn này được dùng rất nhiều. VD: class iPhone có thuộc tính CPU là String và nó có hàm setCPU() => họ có thể tạo 1 class abstract CPU riêng trong đó có nhiều loại class CPU con khác nhau kế thừa từ CPU, bên trong có thuộc tính name và set giá trị được. Tức nó coi setCPU() cũng là 1 hàm chức năng riêng và tách ra class riêng và biến CPU thành thuộc tính của iPhone. Nó cũng có lợi ở chỗ, nếu 2 phone có cùng 1 loại CPU thì k phải setCPU nữa mà tạo 1 instance class loại CPU đó và dùng gán cho cả 2 phone.
=> Trong thực tế, ta vẫn cho 1 class làm nhiều nv, vì dự án lớn mà tách ra như v sẽ có quá nhiều class mất



#***Open/closed principle(OCP): quan trọng nhất
Nguyên tắc là thêm 1 tính năng thì thêm 1 class và implements theo 1 chuẩn chứ k cần phải fix vào những phần code đã viết. 

VD: class Student ta muốn sort theo trường Name thì ta implements Comparable và thực hiện compareTo. Sau đó ta muốn mở rộng rằng Student có thể sort được theo trường Age. Điều ta làm là thêm 1 biến cờ và dùng if else biến cờ đó để sort theo trường nào. Mỗi lần gọi thì truyền thêm biến cờ. K tuần thủ OCP.
V1: CompareByName, CompareByAge 2 class riêng implements Comparable, nhận Student làm private. Sau đó client muốn sort thì khởi tạo 1 list<CompareByName> và cho nó sort là được. Nhờ v mỗi lần thêm 1 tính năng sort sẽ thêm 1 class mới implement Comparable là xong luôn.
V2: Cách trên chưa tốt vì vẫn vi phạm DIP. Ta cho CompareByName và CompareByAge kế thừa abstract class CompareStudent. Abstract class này implements Comparable và có private Student. Để client chỉ cần có CompareStudent là được.
V2 không khác V1 là mấy vì client vẫn có thể dùng List<Comparable> để thế cho 2 class kia nhưng abstract class được khuyển khích sử dụng hơn vì rõ ràng biến Student có chung ở cả 2 class có thể gom chung vào 1 class riêng nx.
Như v client sẽ có 1 list<CompareStudent>. Mỗi lần cần dùng đến sắp xếp kiểu gì thì lại new List<CompareByName> gán cho student rồi gán cho List<CompareStudent> nếu dùng nhiều.

VD2: Falcuty getOffice(), Staff getDept(), Secretary getTypesOfSpeed() cùng kế thừa Employee. Client có list Employee chạy printEmployees chạy for if else type gì thì gọi hàm tương ứng. Mỗi khi thêm 1 class vai trò mới như Director sẽ lại sửa hàm thêm 1 cái if else nữa và lại 1 hàm riêng. Bh ta cần sửa lại để mỗi khi thêm 1 vai trò mới thì chỉ cần thêm 1 class với các hàm theo chuẩn là xong
class Employee abstract có hàm printEmployee, các class kia đều phải implements hàm này, bên trong lại gọi tới hàm tương ứng getOffice hay getDept tùy class. Bên trong Client gọi đúng employee.printEmployee là xong. Nếu ta cần kiểu if là staff thì làm gì, if các cái khác thì làm gì ta vẫn có thể làm tương tự. Nhưng nếu muốn kiểu check nếu là Staff thì in ra, còn k thì k in thì buộc phải if else sẽ là tốt nhất vẫn hơn là Falcuty với Secretary ép tạo ra 1 hàm trống k in vì khi đó nó k còn chung chức năng nữa rồi 
=> K ép các class implements interface nó k muốn(tạo hàm nó k cần).

--> OCP là khi thêm 1 tính năng mới thì logic các phần code cũ không đổi, chỉ cần add class mới, còn nếu sửa 1 tính năng cũ thì phần code cũ bị thay đổi trong 1 phạm vi hẹp. VD chỉ đổi trong 1 class rất gọn. Nhưng phải hiểu cho đúng, thêm 1 tính năng mới là gì?
VD ta có xe đạp thường và xe đạp thường đôi, xe đạp điện. Bh ta thêm xe đạp điện đôi. Về lý thuyết ta có thể thêm bất cứ 1 loại bike gì nhưng việc thêm 1 loại bike mới mà k thay đổi code cũ là 1 điều k thể. Vì bản chất khi ta lấy xe đạp từ database về xong mỗi kiểu bike có 1 kiểu hiển thị khác nhau. Ta k có cách nào k dùng if else mà lại hiển thị bike khác nhau được cả. Do đó thực tế, việc ta thêm 1 bike mới là ta đang đổi tính năng cũ chứ kp là thêm tính năng mới vì thêm tính năng mới tức là thêm 1 tính năng độc lập không liên quan gì tới tính năng cũ chứ vẫn liên quan thì kiểu gì chả đổi logic. 
Trong qtr code, ta luôn cố code sao cho mỗi tính năng ít bị phụ thuộc nhất có thể, để khi 1 tính năng mới thêm vào, nó ít gây ra sự thay đổi với các tính năng đã có hơn. Chứ k thể nào code theo kiểu luôn luôn độc lập dù là thêm bất cứ cái gì(k tính reflection)

Phân tích nếu case trên xảy ra thì: 
Dù biết k thể cản if else, ta vẫn nên chia nhỏ liên tục vì nó sẽ giảm thiểu hơn việc đổi code khi tính năng đổi logic. Ta phải chia ra 1 bike chung và các loại bike kia kế thừa BaseBike. Màn hình hiển thị cũng chia ra mỗi bike 1 màn hình và class màn hình cũng cho kế thừa nhau. 
Lúc này có 2 cách:
1) Lấy từ bảng bike về tất cả, chạy vòng loop check if else loại bike nào thì gán vào màn hình bike item nào và main chứa list các màn hình đó show ra
2) Lấy từng bảng một từng loại bike và với từng loại ta có thể gán trực tiếp vào đúng loại màn hình mà k cần if else
=> 2 cách chọn cách nào cũng được. Cách 1 dù chỉ lấy 1 request từ database nhưng phải check if else duyệt từng bike 1 lần. Cách 2 phải lấy 3 request từ database với từng loại bike



#***LSP và ISP trong SOLID
-> Liskov substitution principle(LSP): Class con có thể thay thế cho class cha ở mọi nơi mà k gây lỗi. 
Vd: class VLCPlayer, WinampPlayer, DIVPlayer đều implements interface Media thực hiện 2 hàm playAudio và playVideo. Ở TH này 1 class thực hiện 2 chức năng (vì nếu là 1 thì chỉ có 1 hàm chính còn các hàm khác sẽ bổ trợ hàm chức năng chính or lấy thông tin phụ gì khác) nhưng ta kqt ở đây. Client có playVideo và playAudio gọi đến các hàm đó của Media. VĐ là chỉ riêng WinampPlayer k có playVideo() nhưng nó vẫn thực hiện hàm đó và bên trong throw ra thông báo lỗi. Tức là ở đây ta coi Media là cha và 3 class kia là con thì vi phạm LSP vì có con k thể thay thế cho cha vì k có playVideo. Fix bằng cách tách ra MediaAudioPlay và MediaVideoPlay và dùng 2 interface này dependency đến hàm của client thôi. 
Ở đây k dùng interface kế thừa interface vì biết đâu sau này thêm 1 class mới chỉ có playVideo thì sao.

-> Interface segregation principle(ISP): Client k nên bị ép buộc phải implement interface mà nó k dùng, phải tách interface.

VD klq: nếu 1 class Media có thể có 1 trong 3 loại Player, ta chỉ cần cho class Media có thuộc tính là class Player, truyền instance vào hàm để gán khởi tạo player. Nếu như có nhiều loại Media có 1 trong 3 loại player thì cho nó kế thừa media là xong (Media thành abstract). Nếu như có 1 loại class tương đồng type với Media nhưng kp Media nhưng cũng có thể có 1 trong 3 loại player thì cũng cho nó aggregation đến MediaPlayer là được. 



#***Constructor injection và Method injection
VD: class School có 1 biến là CompareByName cho list Students và trong hàm khởi tạo nó ta new nó và hàm sort ta compareByName.sort() là được => nhưng class high level là School lại phụ thuộc vào class low level là CompareByName khi nó đổi sang CompareByAge là sai chưa. Do đó cần tạo abstract cho nó là class CompareStudent chung, còn khi nào dùng thì compareStudent = new CompareByName() là được. Muốn so sánh kiểu gì thì các class con như CompareByAge phải phụ thuộc vào cấp cao. là CompareStudent mới đúng.
VĐ là khởi tạo CompareByStudent ở đâu?
- Constructor injection: compareStudent = compareByName với compareByName là tham số truyền vào constructor nếu biến này cần dùng ở ngoài kia nữa chứ có phải lúc nào cũng tạo new, và trong class chỉ dùng cái compareByName là mặc định
- Method injection trong hàm sort: compareStudent.sort() với compareStudent là đối số nhận vào và k cần là biến private của class => dùng khi nó chỉ dùng ở hàm này chứ k dùng ở nhiều chỗ nào khác trong class
=> Phạm vi biến ảnh hưởng đến việc khởi tạo nó như nào. Tất cả visibility hay phạm vi biến gọi đều phải tối ưu.



-> Nhanh:
SRP: Class chỉ 1 chức năng chính, các hàm khác chỉ bổ trợ chức năng chính, nếu nhiều chức năng thì phải tách ra
OCP: Timer phụ thuộc vào TimeToStretch, nếu sau này có TimeToListenToMusic sẽ phải tạo thêm 1 biến mới. Thay vì v, dùng List<TimerTask> chung
DIP: class tầng cao k phụ thuộc vào lớp thấp hơn, nếu có, phải abstract class và cho class tầng thấp phụ thuộc vào abstract class
LSP: các class con đồng cấp có thể thay thế cho nhau. VD: A nằm trong C, A đồng cấp với B thì B cũng có thể nằm trong C mà k bị sai ý nghĩa
ISP: class implement interface mà k thực sự cần implement 1 hàm trong interface, nên tách thành interface riêng cho nó



#***Master cohesion and Coupling: 
Coupling là sự phụ thuộc lẫn nhau của các module. Các thành phần trong phần mềm nên phụ thuộc càng ít chặt chẽ càng tốt. Để đảm bảo điều này, khi code ta thử thay đổi các thành phần trong 1 module rồi check xem các module khác có thay dổi code nhiều không
Cohesion là các thành phần bên trong class nên phụ thuộc càng chặt chẽ thì càng tốt. Nếu đảm bảo được điều này khi code, ta chắc chắn class sẽ chỉ làm 1 nhiệm vụ thì các thành phần của 1 chức năng sẽ liên quan tới nhau. Ngược lại sẽ rất rối. VD class Invoice sẽ k lưu trường customer_name vì trường này được lưu trong class Customer hay class Payment vì class Invoice chỉ tính toán hóa đơn k liên quan. Nếu lưu vào sẽ vi phạm high cohesion

-> Có nhiều loại:
- Coupling:
1) Content Coupling:
1 class truy xuất trực tiếp biến 1 class khác. Nên thêm getter, setter chẳng hạn
Để private + getter setter khác gì với để public. Dù getter setter lấy y hệt như biến gốc cũng k nên dùng public vì nó vi phạm coupling. Sau này khi ta muốn setter và getter của nó thay đổi chứ k còn lấy y hệt nữa. Ta sẽ phải tìm từng chỗ ở mọi class khác để chuyển từ lấy trực tiếp sang gọi getter rất phiền toái.
2) Common coupling: mọi module dùng chung 1 global class, đổi biến và hàm của global class làm mọi module phải đổi. 
Để tránh CC, có thể biến global store thành 1 module riêng và cung ra các hàm quản lý quyền truy cập và thay đổi giá trị. Định nghĩa interface để đổi trong phạm vi cho phép. Dùng DI cho global store để inject vào module nào cần dùng với AddTransient hay AddSingleton, tránh global mọi chỗ vì kp module nào cũng dùng.
3) Control coupling: 1 module control flow của module khác. VD callback function hay callapi hay event handler mà khởi tạo fix cứng. Để fix thì ta nên truyền các cái đó vào dưới dạng tham số thay vì new trong hàm là xong.
4) Stamp coupling (từ đây chấp nhận được): Truyền cả object vào nhưng thực tế chỉ cần 1 vài trường trong đó, thừa params. Fix bằng cách hãy truyền đúng các params đó thôi
5) Data coupling(mô hình ổn nhất): các module chỉ tương tác với nhau thông qua params truyền vào (k quá nhiều params). Nó giống stamp coupling nhưng tốt hơn vì params truyền vào k dư thừa

- Cohesion:
1) Coincidental: Những phần tử nằm chung vị trí với các component khác trong module nhưng lại chả phục vụ gì cho xử lý logic chức năng. VD thêm 1 hàm bừa vào class mà nó kbh được gọi trong class đó. Or nó được dùng trong class nhưng k nên là 1 phần của class vì k giúp ích cho chức năng chính. Phải tách class riêng.
2) Logical Cohesion: Là khi các components liên quan logic chứ k lq chức năng. VD: 3 function đọc data từ tape, disk, network chung 1 module => nghe ổn vì 3 cái cùng 1 loại chức năng nhưng nó k liên quan đến nhau sẽ vi phạm cohesion. Dù nó có vài hàm có thể gọi chung tái sử dụng or chung 1 loại biến thì nên tạo 1 interface để nó override lại readInput, vẫn là các module khác nhau sẽ tốt hơn
3) Temporal cohesion: VD gom 10 hàm độc lập vào 1 hàm khác trong 1 class vì chúng được gọi cùng lúc, VD 10 hàm init hay 10 hàm cleanup. VD trong đó 5 hàm clean up resource, 5 hàm close db connection, thì tách thành 2 hàm nhỏ, mỗi hàm gọi 5 hàm và gọi 2 hàm nhỏ trong hàm close(), chứ đừng để hàm close gọi cả 10 hàm.
4) Procedural cohesion: Giống cái trên nhưng kp các hàm được gọi cùng lúc, mà các hàm nằm trong 1 flow logic cụ thể. Thg gặp khi làm facade pattern, cần chú ý tách ra nhé.
5) Communicaional cohesion: Giống cái trên nhưng hàm bị gom do thao tác trên cùng 1 data.
6) Sequential cohesion (thiết kế từ đây là tốt): Bị gom lại do output của 1 hàm là input của 1 hàm khác là đúng.
7) Functional cohesion: Tất cả các element trong component đều cần thiết cho mục đích chính của component



# Other
-> Heisenbug là một thuật ngữ trong lập trình máy tính để chỉ một lỗi hoặc hành vi không thể tái hiện được đúng như mong đợi. Thuật ngữ này được đặt theo tên của nguyên lý không xác định Heisenberg trong vật lý, nghĩa là việc đo lường sẽ ảnh hưởng đến hành vi của hệ thống đang được quan sát.

black art: chỉ những hoạt động tối mật liên quan đến lập trình, hacking, an ninh mạng. Debug cũng là 1 black art dù nó theo nghĩa tốt



