# Tư duy cơ bản trong OOP
-> Khi có 1 biến trong class này mà ta muốn dùng nó ở 1 hàm trong class khác. Ta có thể mỗi lần gọi hàm đó là pass từ từ biến qua function cho đến đích nó dùng. Nhưng nếu biến đó được dùng nhiều lần trong nhiều hàm của class đó thì có thể truyền vào làm 1 thuộc tính của class từ constructor để mọi lần đều lấy được trực tiếp vì aggregation ở đây nó refer tới địa chỉ. Nhưng cần phải cẩn thận vì vc đặt bừa bãi từng bước có thể làm hỏng OOP, ta cần cân nhắc biến kia có phải là 1 tính chất, 1 thuộc tính thực sự của class hay k. Vì có thể dependency TH đó đúng với OOP hơn.

-> VD:
Trong class Step có aggregation class PseudoStep và ở đây ta đang cần lưu 1 list string là từng dòng pseudocode và 1 cái label để gán giá trị từng dòng đó hiển thị ra giao diện. Câu hỏi là class PseudoStep chứa cái gì ? Nó chứa cả cái list string và label hay chỉ chứa Label còn list string chứa trong Step:
- Nếu class Step chứa list String và PseudoStep chứa label thì: logic buộc phải viết trong Step nên sẽ bất tiện nếu class Step chứa rất nhiều loại step khác chứ k chỉ PseudoStep, tức là file này sẽ to ra, PseudoCode chứa mỗi 1 cục Label mà được tạo bằng fxml thì class này quá thừa thãi, nhưng 1 class Alg chứa 1 listStep nếu muốn thao tác có thể gọi trực tiếp từ hàm của Step sẽ tiện
- Nếu Pseudo code chứa hết cả list string và label thì logic thích viết ở đâu cũng được và vc chia file rất gọn nhưng nếu từ class Alg muốn thêm 1 phần tử vào list string chẳng hạn sẽ phải truyền qua Step -> PseudoStep thì vc forward như này làm code nó k tối ưu vì sai ngay từ quan hệ aggregation "là" mà.
=> Cách 2 tốt hơn dù vẫn tệ. Nếu ta thêm chức năng mới mà file Step to đùng ra xong chỉnh sửa nhiều làm code rối, đó là chưa tối ưu.

-> Tức là khi ta tạo ra 1 class nào đó, hãy nhớ rằng class đó làm 1 tính năng và code như nào để class này thể hiện tính năng này có thể tái sử dụng khi 1 component khác cũng cần tính năng này. Tức khi quyết định tạo 1 file mới cho 1 class mới. Ta phải tính 2 tình huống:
1) 1 class khác cũng dùng tính năng này thì có tái sử dụng được k
2) Thêm 1 tính năng mới tương tự như tính năng này vào thì code có phải chỉnh sửa nh không.

-> Cân nhắc dùng protected để tạo ra quyền truy cập nhanh hơn ở lớp kế thừa, đỡ phải get liên tục. Nếu chỉ cần dùng ở class con thì dùng protected là lý tưởng. Nếu cần dùng bên ngoài thì private + get + set là lý tưởng. K dùng public cho biến trong class.
VD: Nếu lồng 10 class kế thừa nhau thì class cấp 10 có thể truy cập biến class cấp 1 thoải mái mà k cần dùng 9 hàm getter. Còn API thay đổi có thể dùng thoải mái trực tiếp



#***Hiểu 1uan hệ các class trong OOP
VD: Thay vì dùng WindowWithScrollbar kế thừa Window và Scrollbar là multiple inheritance có thể k dùng được trong 1 số ngôn ngữ và bị sai quan hệ ở đây, ta dùng Scrollbar composition trong WindowWithScrollbar(vì window xóa thì scrollbar ta cũng muốn xóa theo và window chỉ gắn với 1 scrollbar tạo ra chỉ dùng bên trong, k dùng ở ngàoi) và WindowWithScrollbar kế thừa từ Window. Đúng quan hệ has-a và is-a

Vd ta cho PseudoStep và DetailStep là aggregation của Step thì bản thân nó phải mang ý nghĩa là 1 thuộc tính của Step. VD: class Person có tóc, tai, mắt, mũi,.. còn PseudoStep nó vốn kp là 1 tính chất của Step mà nó là quan hệ "là" nên đúng ra là phải kế thừa. Nhưng nếu DetailStep và PseudoStep cùng kế thừa Step nhưng lại chẳng có hàm gì chung thì kế thừa chả để làm gì. 1 phần cũng là do lỗi đặt tên vì nó giống quan hệ "là". Ở đây có thể đôi tên của Step sao cho nó chứa PseudoStep như 1 thuộc tính kiểu StepContainer chẳng hạn.
VD: Edge và Comment của DetailStep có thể tách thành 2 class riêng nằm trong DetailStep.
VD: PseudoStep là 1 thuộc tính của Algorithm thì nên xây ngay tại constructor của từng thuật toán ok hơn.



# Thêm 1 chức năng mới thì chỉ cần làm ở 1 file là tự có hết chứ kp code mở rộng to dần ở 1 file cũ và xử lý code phức tạp ở nhiều class. 
Vd trong ứng dụng có các class hình tròn, hình vuông, hình thoi,... để thao tác gì đó ta k cần biết, nhưng 1 lúc nào đó ứng dụng cần mở rộng bằng cách thêm 1 hình mới vào là hình tam giác chẳng hạn thì chỉ cần thêm 1 class Triangle vào phát là xong mà k cần chỉnh sửa thêm ở nhiều class để thêm 1 tính năng mới.

- Interface + aggregation:
Client có AMedia abstract được kế thừa từ Disc, Book, Audio. Vc này đã là gom chung rồi nhưng h 3 class kia có cùng 1 hàm mà ta muốn implements hàm đó trong Client thì có thể cho 3 cái implement interface và gọi thông qua interface. Tức client dependency đến interface. Như v nghe khá ổn nhưng vẫn chưa hoàn toàn tuân thủ SRP. Chẳng hạn cần tuân thủ SRP và hàm chung ở đây là play() đi thì interface là Playable. Ta tạo ra 3 class DiscPlay, BookPlay, AudioPlay implements interface Playable. Rồi Client gọi play() dependency Playble thông qua 3 class kia. Nhưng như thế thì 3 class Disc, Book, Audio cũng phải aggregation đến các class Play. Đương nhiên nó được truyền vào khi khởi tạo ra để dùng trong Client.



#***Các class cùng kế thừa abstract nhưng có 1 class khác biệt lẻ ra
A, B, C kế thừa abstract class D và khởi tạo instance D new A B C thì chẳng may B có 1 hàm lẻ mà 2 class kia k có thì khi cần gọi có thể cast sang B để gọi.

A, B, C cùng kế thừa từ abstract class D vì cả 3 cùng có 1 hàm là run() nhưng class C khác class A và B 1 chút là run của C nhận thêm đối số x vào hàm cơ. Khi đó để hàm run() là hàm abstract trong D thì phải biến cái x thành aggregation của C khi khởi tạo từ constructor là được, hàm run() lại thành k đối số
=> Sẽ rất tệ nếu x nó k là 1 thuộc tính của C mà chỉ là 1 thứ vớ vẩn phụ thêm, khi đó có thể dùng default params cho hàm, hoặc tách riêng ra



# Hướng xây dựng OOP:
Ta chỉ dùng interface nếu nhiều class cùng 1 chức năng thì cùng kế thừa 1 interface - 1 responsibilities. Chứ nếu chỉ có 1 class thì chả cần phải tạo interface làm gì.
Viết đúng quan hệ hướng đối tượng, class nào chứa class nào là thuộc tính, class nào kế thừa quan hệ "là" với class nào.

//!!!!!!!
-> OOP ta biết cái graph là biến private nhưng nếu ta cho hàm getGraph trả ra biến graph đó thì liệu có được. Vì nếu dùng getGraph, ta sẽ toàn quyền thay đổi về property của cái Graph. Tùy thuộc vào class Graph có quyền thay đổi như nào mà ta có thể đổi graph của class đó thoải mái. Nếu class Graph là kiểu class thuần được toàn quyền thay đổi vì có đầy đủ getter, setter thì điều này vô hình làm tính đóng gói trở nên lố bịch vì class nào cũng thay đổi được mọi thứ.
Do đó, Vd class A có Graph graph thì:
Nếu ta muốn thay đổi bản thân của biến graph sang 1 địa chỉ riêng thì cần tạo setter cho graph.
Nếu graph là biến class thuần được thay đổi mọi thứ ngoài tầm kiểm soát của class A thì: nếu muốn thay đổi toàn quyền biến graph thì tạo hàm getter cho nó; nếu muốn thay đổi graph theo ý muốn chỉ được thông qua các API của class A thì ta bỏ hàm setter đi và tạo ra các hàm API set attribute cho cái graph của class A riêng, nhưng điều này cũng đồng nghĩa class A có rất nhiều hàm bị trùng với class Graph nếu như vc set attribute là k đổi và nếu cần thay đổi đến 100 thuộc tính thì sẽ lên tới 100 hàm rất lớn
=> Nếu k muốn class A làm như v có thể làm 1 PP khác: tạo 1 class CustomGraph extends Graph và class này giữ mọi thuộc tính setter getter của Graph nhưng muốn thay đổi như nào khi dùng class A thì chỉ cần override các thuộc tính cần thay đổi. Nhờ v thì class A k cần phải viết logic trùng lặp. Điều đặc biệt là điều này giúp tách logic class A ra rất nhiều nhưng nếu CustomGraph cần dùng đến biến của class A để dùng trong hàm setter thì: 
1) Ta vẫn có thể tạo API tiếp trong class A để gọi vào 1 hàm từ class CustomGraph nhưng class CustomGraph k có cách nào xóa thuộc tính từ Graph được. Ta phải tự hiểu là k dùng hàm đó trong Graph nhưng thông thường thay đổi data thông qua biến của class A thì thường hàm đó bị đổi chức năng 1 tẹo nên có thể chơi kiểu 2 hàm, 1 hàm gán gì cũng được, 1 hàm gán theo thuộc tính của class A thì 2 chức năng khác nhau cũng ok.
2) Cách 2 là ta cho CustomGraph chứa các biến aggregation là các biến từ class A kiểu:
class A {
  private int a;
  private CustomGraph graph;
  public A(int b){
    a = b;
    graph = new CustomGraph(a); //a phải là thuộc tính của custom graph
  }
}
thì khi class CustomGraph dùng địa chỉ biến từ class A là dùng được các biến của class A nhưng bị giới hạn k được nhiều biến. Vẫn áp dụng Cách 1 kèm được còn Cách 2 chỉ dùng với các biến dùng nhiều kiểu biến a nó như hẳn 1 thuộc tính của CustomGraph. 
Tức là ở trong class Step có PseudoStep làm 1 biến private và ta muốn add vào hay làm gì thì ghi lại đúng. Bh ta getPseudoStep phát là xong thay vì gọi truyền nhau.
=> Chưa giải quyết được VD: A có aggregation B. B có 5 hàm a,b,c,d,e. Ta muốn A k dùng được a,b. A dùng được c,d như cũ. A custom e() khác đi => số lượng hàm ở đây VD cực lớn. Khi này a, b k dùng được thì ta đơn giản là k thay đổi gì cả mà ẩn nó đi, k gọi đến nó là xong chứ k nhất thiết phải tìm cách để y hệt v đâu. 
Giải quyết vấn đề này theo cách tốt nhất mà ta biết thì phải tạo customgraph và implement thuộc tính e và getCustomGraph. Nhớ chú ý thỏa mãn tính chất method phải là 1 hành động của object. 
Hoặc nếu class ngắn thì có thể: để getter cho biến private đó + vẫn viết các hàm mà có sự thay đổi theo ý ta trong class A. Chấp nhận vc người khác có thể dùng getter để từ đó set giá trị linh tinh vì rảnh lắm mới làm v.


